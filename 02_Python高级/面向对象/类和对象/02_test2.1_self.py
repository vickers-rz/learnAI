# self关键字: 谁调用run函数，self就是谁
# 做实验: 两个不同的对象 self 是不一样的

# ---------------------------------------------------------------
# 一、self的原理与意义：
# self是Python中非常核心的面向对象编程机制之一。
# 它用于在类的方法中引用当前对象实例，用来区分是哪个对象在调用方法。
# 当多个对象共享同一个类的方法时，self保证每个对象都能独立操作自己的数据。
# 从原理上看：类（class）与对象（object）是一对多的关系。
# self就是Python解释器为了解决“一对多关系”而自动引入的机制，用来让方法知道“是谁在调用我”。
# ---------------------------------------------------------------

# 1 定义类
class Car:
    # 2 定义类的方法
    def run(self):
        # self在这里表示当前调用该方法的对象实例
        # 例如mycar01.run()时，self代表mycar01
        # 而mycar02.run()时，self代表mycar02
        print(f"能跑起来...{self}")  # 打印出当前对象的内存地址，用来区分不同对象


# 3 创建对象
# 3.1 创建具体的对象
mycar01 = Car()
# 3.2 调用类的方法
print("mycar01 -->", mycar01)
mycar01.run()  # 此时self指向mycar01

# 4 再创建对象2
mycar02 = Car()
print("mycar02 -->", mycar02)
mycar02.run()  # 此时self指向mycar02，和上一个对象不同

# ---------------------------------------------------------------
# 二、通过实验我们可以发现：
# self的值取决于哪个对象调用了类的方法。
# Python解释器在执行 mycar01.run() 时，会自动将mycar01传递给self。
# 所以我们不需要手动传参，Python解释器会帮我们完成这一过程。
# ---------------------------------------------------------------


# self关键字的作用: 在类的内部调用类的方法
# 使用语法: 在类的内部使用 self.方法() 的形式调用同一个类的其他方法
# ---------------------------------------------------------------
# 三、self的进一步用法与注意事项：
# 1. self必须是实例方法的第一个参数，但调用时不需要传入。
# 2. self不是关键字，而是一种命名约定。你也可以写成this等别的名字，但不建议那样做。
# 3. 使用self可以在类的不同方法中共享同一个对象的数据。
# 4. self用于访问实例属性（self.xxx）和调用实例方法（self.xxx()）。
# ---------------------------------------------------------------


# 1 定义类
class Car:
    # 2 定义类的方法
    def run(self):
        print(f"能跑起来...{self}")

    def work(self):
        # 在类的内部调用自身的另一个方法时，需要使用 self.方法()
        # 这里self指向当前对象，因此self.run()等价于当前对象.run()
        self.run()


# 3 创建对象
mycar01 = Car()
# 3.2 调用类的方法
mycar01.work()  # 这里work方法中调用了run，二者的self是同一个对象mycar01

"""
# 四、总结：
# 1. self是类和对象之间通信的桥梁，是区分不同对象调用类方法的关键。
# 2. self由Python解释器自动传入，不需要手动指定。
# 3. 在类内部定义方法时，第一个参数必须写self，否则解释器无法正确绑定对象。
# 4. self确保每个对象拥有独立的属性与方法，不会与其他对象混淆。
"""
# 这样整理后，整个代码不仅展示了 `self` 的行为，还通过注释解释了其设计原因、底层逻辑以及用法规范，适合课堂讲解或教学资料使用。
