# 递归教学说明

## 什么是递归？

递归是一种编程技术，其中函数调用自身来解决问题。它把一个大问题分解成相似的小问题，直到达到最简单的情况（称为基本情况或终止条件）。

## 递归的核心要素

每个递归函数都需要满足以下两个条件：

1. **基本情况(Base Case)**：递归必须有一个或多个不需要继续递归就能解决的简单情况
2. **递归步骤(Recursive Step)**：函数调用自身，但参数要向基本情况靠近

## 分析递归查找代码

```python
def linear_search_recursive(lst, target, index=0):
    # 基本情况1：已检查完所有元素仍未找到
    if index == len(lst):
        return -1
    
    # 基本情况2：在当前位置找到了目标元素
    if lst[index] == target:
        return index
    
    # 递归步骤：检查下一个位置
    return linear_search_recursive(lst, target, index + 1)
```

这段代码实现了递归线性搜索：

1. **基本情况**：
   - 当 index 等于列表长度时，表示已搜索完整个列表但未找到目标，返回 -1
   - 当 `lst[index]` 等于目标值时，找到了目标，返回当前索引

2. **递归步骤**：
   - 如果当前元素不是目标，则调用自身，将索引加1，继续在剩余部分搜索

## 递归执行过程详解

以查找元素为例，假设我们要在 `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3]` 中查找 `9`：

```
linear_search_recursive([3,1,4,1,5,9,2,6,5,3], 9, 0)
|-- index=0, lst[0]=3 ≠ 9, 继续递归
|-- linear_search_recursive([3,1,4,1,5,9,2,6,5,3], 9, 1)
    |-- index=1, lst[1]=1 ≠ 9, 继续递归
    |-- linear_search_recursive([3,1,4,1,5,9,2,6,5,3], 9, 2)
        |-- index=2, lst[2]=4 ≠ 9, 继续递归
        |-- linear_search_recursive([3,1,4,1,5,9,2,6,5,3], 9, 3)
            |-- index=3, lst[3]=1 ≠ 9, 继续递归
            |-- linear_search_recursive([3,1,4,1,5,9,2,6,5,3], 9, 4)
                |-- index=4, lst[4]=5 ≠ 9, 继续递归
                |-- linear_search_recursive([3,1,4,1,5,9,2,6,5,3], 9, 5)
                    |-- index=5, lst[5]=9 == 9, 返回索引5
```

## 递归 vs 循环

递归和循环都可以解决相同的问题，但各有优劣：

1. **递归优点**：
   - 代码简洁，易于理解
   - 自然地表达了某些问题的解决方案（如树遍历、分治算法）

2. **递归缺点**：
   - 可能导致栈溢出（深度过大时）
   - 性能通常不如循环（函数调用开销）

3. **循环优点**：
   - 性能更好
   - 不会出现栈溢出问题

4. **循环缺点**：
   - 对于某些问题，代码可能更复杂

## 何时使用递归？

递归特别适用于以下情况：
1. 问题可以分解为相似的子问题
2. 有明确的基本情况
3. 数据结构本身具有递归特性（如树、图）
4. 使用分治法解决问题时