# -*- coding: utf-8 -*-
"""
选择排序 (Selection Sort)
"""

def selection_sort(arr):
    """
    选择排序
    
    原理：每次从未排序的部分中选择最小的元素，
    放到已排序部分的末尾。通过逐步减少未排序部分来进行排序。
    
    Args:
        arr: 待排序的列表
        
    Returns:
        排序后的列表
    """
    print(f"开始选择排序，初始数组: {arr}")
    # 外层循环：从头到尾遍历整个数组，每次找最小值
    for i in range(len(arr)):
        # 假设当前位置的元素是未排序部分中的最小元素
        min_idx = i
        print(f"\n--- 第 {i+1} 轮选择 ---")
        print(f"  假设 arr[{i}]={arr[i]} 是未排序部分 [{arr[i:]}] 的最小值")

        # 内层循环：从i后面的位置开始找最小的元素
        for j in range(i + 1, len(arr)):
            # 如果找到了比当前最小值还小的元素，就更新最小元素的位置
            print(f"  比较 arr[{j}]={arr[j]} 和当前最小值 arr[{min_idx}]={arr[min_idx]}")
            if arr[j] < arr[min_idx]:
                min_idx = j
                print(f"    发现更小值，更新最小值索引为 {min_idx}")

        # 交换当前元素与找到的最小元素
        if min_idx != i:
            arr[i], arr[min_idx] = arr[min_idx], arr[i]
            print(f"  交换 arr[{i}] 和 arr[{min_idx}]，数组变为: {arr}")
        else:
            print(f"  最小值已在正确位置，无需交换")

    print(f"选择排序完成，最终数组: {arr}")
    return arr

"""
解释：

1. 外层循环：for i in range(len(arr))
   依次遍历数组的每一个位置，将未排序部分的最小值放到当前位置。
   
2. 内层循环：for j in range(i + 1, len(arr))
   从当前位置后面开始找比当前元素更小的值。
   
3. 最小值更新：if arr[j] < arr[min_idx]
   如果找到了一个更小的元素，就记录它的位置。
   
4. 交换：arr[i], arr[min_idx] = arr[min_idx], arr[i]
   将最小值和当前元素交换。

复杂度分析：
- 时间复杂度：
  - 最坏情况：O(n²)
  - 最好情况：O(n²)
  - 平均情况：O(n²)
- 空间复杂度：O(1) - 只使用了常数级别的额外空间

适用场景：
- 数据量较小的情况
- 对内存使用要求严格的场景（原地排序）
- 不适合对稳定性有要求的场景（选择排序是不稳定的）
- 交换次数少，适用于写操作成本高的场景

案例演示：
假设我们要对数组 [64, 34, 25, 12, 22, 11, 90] 进行排序：

第1轮选择：
- 在整个数组中找最小值，找到11，与位置0的64交换
- 数组变为 [11, 34, 25, 12, 22, 64, 90]

第2轮选择：
- 在[34, 25, 12, 22, 64, 90]中找最小值，找到12，与位置1的34交换
- 数组变为 [11, 12, 25, 34, 22, 64, 90]

思路解析：
选择排序是一种直观的排序方法，每一轮都从未排序部分选出最小元素放到已排序部分的末尾。
无论输入数据如何，都需要进行n-1轮选择，所以时间复杂度始终是O(n²)。
与冒泡排序相比，选择排序的交换次数更少，最多进行n-1次交换。
"""