# -*- coding: utf-8 -*-
"""
快速排序 (Quick Sort)
"""

def quick_sort(arr):
    """
    快速排序
    
    原理：一种分治法排序，通过选择一个基准元素，
    将数组分成两部分，递归排序后合并。
    
    Args:
        arr: 待排序的列表
        
    Returns:
        排序后的列表
    """
    print(f"快速排序数组: {arr}")
    # 递归出口：如果数组为空或只有一个元素，则直接返回
    if len(arr) <= 1:
        print(f"  数组长度 <= 1，直接返回: {arr}")
        return arr

    # 选择基准元素，这里选择中间的元素
    pivot = arr[len(arr) // 2]
    print(f"  选择基准元素: {pivot}")
    
    # 将数组分成三部分：小于基准、等于基准、大于基准
    left = [x for x in arr if x < pivot]    # 小于基准
    middle = [x for x in arr if x == pivot] # 等于基准
    right = [x for x in arr if x > pivot]   # 大于基准
    print(f"  分割为: 小于基准 {left}, 等于基准 {middle}, 大于基准 {right}")

    # 递归对左边和右边部分进行排序
    print(f"  递归排序左半部分 {left}:")
    sorted_left = quick_sort(left)
    print(f"  递归排序右半部分 {right}:")
    sorted_right = quick_sort(right)
    
    result = sorted_left + middle + sorted_right
    print(f"  合并结果: {result}")
    return result

"""
解释：

1. 基准元素选择：pivot = arr[len(arr) // 2]
   选择数组的中间元素作为基准。
   
2. 三部分划分：
   通过列表推导式，将数组分成小于基准、等于基准和大于基准的三部分。
   
3. 递归排序：
   对左右部分分别进行递归排序，再将三部分合并。

复杂度分析：
- 时间复杂度：
  - 最坏情况：O(n²) - 每次选到最大或最小元素作为基准
  - 最好情况：O(n log n) - 基准总是中位数
  - 平均情况：O(n log n)
- 空间复杂度：平均 O(log n)，最坏 O(n) - 递归调用栈的深度

适用场景：
- 数据量较大的情况
- 内存使用要求不严格的情况
- 不要求稳定性的场景
- 通常是实际应用中最快的排序算法
- 适合用于大数据集的随机排序

案例演示：
假设我们要对数组 [64, 34, 25, 12, 22, 11, 90] 进行排序：

第一层递归：
- 选择基准元素 12
- 分割为: 小于基准 [], 等于基准 [12], 大于基准 [64, 34, 25, 22, 11, 90]

对右半部分 [64, 34, 25, 22, 11, 90] 继续递归：
- 选择基准元素 25
- 分割为: 小于基准 [11, 22], 等于基准 [25], 大于基准 [64, 34, 90]

继续递归直到所有子数组有序，然后合并。

思路解析：
快速排序也是一种分治算法，通过基准元素将数组分为三部分。
与归并排序不同，快速排序在分解阶段进行实际工作（分割数组），而在合并阶段不做工作。
基准元素的选择对性能影响很大，理想情况下应该选择中位数。
快速排序是不稳定的排序算法，因为相等元素可能在分割过程中改变相对位置。
"""