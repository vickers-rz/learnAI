# -*- coding: utf-8 -*-
"""
排序算法实现
==============

本文件包含五种常用的排序算法实现：
1. 冒泡排序 (Bubble Sort)
2. 选择排序 (Selection Sort)
3. 插入排序 (Insertion Sort)
4. 归并排序 (Merge Sort)
5. 快速排序 (Quick Sort)
"""

### 1. 冒泡排序 (Bubble Sort)
### ------------------------------------------------------------------------

def bubble_sort(arr):
    """
    冒泡排序
    
    原理：通过两两比较相邻的元素，将较大的元素"冒泡"到数组的末尾。
    它会重复比较并交换，直到整个数组有序。
    
    Args:
        arr: 待排序的列表
        
    Returns:
        排序后的列表
    """
    # 获取数组的长度
    n = len(arr)
    print(f"开始冒泡排序，数组长度: {n}, 初始数组: {arr}")

    # 外层循环控制进行多少轮比较，每一轮都会让一个最大元素浮动到数组的末尾
    for i in range(n):
        print(f"\\n--- 第 {i+1} 轮冒泡 ---")
        # 设置一个标志变量，用来检查是否有发生交换操作
        swapped = False

        # 内层循环进行相邻元素的比较
        # 内层循环长度逐渐缩小，因为每次外层循环后最大的元素已经"冒泡"到最后
        for j in range(0, n - i - 1):
            print(f"  比较 arr[{j}]={arr[j]} 和 arr[{j+1}]={arr[j+1]}")
            # 如果当前元素大于下一个元素，则交换它们
            if arr[j] > arr[j + 1]:
                # 交换操作，Python中的交换方式
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True  # 如果发生了交换，标记为True
                print(f"    交换后数组: {arr}")
            else:
                print(f"    无需交换")

        print(f"  第 {i+1} 轮结束，数组状态: {arr}")
        # 如果没有发生交换，说明数组已经是有序的，提前退出循环
        if not swapped:
            print("  本轮无交换，数组已有序，提前结束")
            break

    # 返回排序后的数组
    print(f"冒泡排序完成，最终数组: {arr}")
    return arr

"""
解释：

1. 外层循环：for i in range(n)
   控制排序的轮数。每完成一轮，最值会被放到末尾，
   下一轮只需要对前面未排序的部分进行排序。
   
2. 内层循环：for j in range(0, n - i - 1)
   比较相邻的元素。随着每轮外层循环的结束，i的增大，
   内层循环的范围逐渐减小。
   
3. 交换：
   如果发现相邻元素不符合顺序（例如 arr[j] > arr[j + 1]），
   则交换它们的位置。
   
4. 提前退出：
   如果某一轮没有发生任何交换，说明数组已经排好序，
   可以提前退出循环。

复杂度分析：
- 时间复杂度：
  - 最坏情况：O(n²) - 数组完全逆序
  - 最好情况：O(n) - 数组已经有序
  - 平均情况：O(n²)
- 空间复杂度：O(1) - 只使用了常数级别的额外空间

适用场景：
- 数据量较小（通常n<50）
- 数据基本有序的情况下效率较高
- 稳定排序算法，适用于需要保持相等元素相对位置的场景
- 教学演示排序算法原理的经典例子

案例演示：
假设我们要对数组 [64, 34, 25, 12, 22, 11, 90] 进行排序：

第1轮冒泡：
- 比较 64 和 34，64>34，交换 → [34, 64, 25, 12, 22, 11, 90]
- 比较 64 和 25，64>25，交换 → [34, 25, 64, 12, 22, 11, 90]
- 比较 64 和 12，64>12，交换 → [34, 25, 12, 64, 22, 11, 90]
- 比较 64 和 22，64>22，交换 → [34, 25, 12, 22, 64, 11, 90]
- 比较 64 和 11，64>11，交换 → [34, 25, 12, 22, 11, 64, 90]
- 比较 64 和 90，64<90，不交换 → [34, 25, 12, 22, 11, 64, 90]
第1轮结束，最大值90已经"冒泡"到末尾，次大值64也到了该在的倒数第二位置

思路解析：
冒泡排序就像水中气泡上浮一样，较大的元素会逐步"浮"到数组末尾。
每一轮都会确定一个最大元素的最终位置，所以外层循环最多需要n-1轮。
通过swapped标志可以优化最好情况下的性能。
"""


### 2. 选择排序 (Selection Sort)
### ------------------------------------------------------------------------

def selection_sort(arr):
    """
    选择排序
    
    原理：每次从未排序的部分中选择最小的元素，
    放到已排序部分的末尾。通过逐步减少未排序部分来进行排序。
    
    Args:
        arr: 待排序的列表
        
    Returns:
        排序后的列表
    """
    print(f"开始选择排序，初始数组: {arr}")
    # 外层循环：从头到尾遍历整个数组，每次找最小值
    for i in range(len(arr)):
        # 假设当前位置的元素是未排序部分中的最小元素
        min_idx = i
        print(f"\\n--- 第 {i+1} 轮选择 ---")
        print(f"  假设 arr[{i}]={arr[i]} 是未排序部分 [{arr[i:]}] 的最小值")

        # 内层循环：从i后面的位置开始找最小的元素
        for j in range(i + 1, len(arr)):
            # 如果找到了比当前最小值还小的元素，就更新最小元素的位置
            print(f"  比较 arr[{j}]={arr[j]} 和当前最小值 arr[{min_idx}]={arr[min_idx]}")
            if arr[j] < arr[min_idx]:
                min_idx = j
                print(f"    发现更小值，更新最小值索引为 {min_idx}")

        # 交换当前元素与找到的最小元素
        if min_idx != i:
            arr[i], arr[min_idx] = arr[min_idx], arr[i]
            print(f"  交换 arr[{i}] 和 arr[{min_idx}]，数组变为: {arr}")
        else:
            print(f"  最小值已在正确位置，无需交换")

    print(f"选择排序完成，最终数组: {arr}")
    return arr

"""
解释：

1. 外层循环：for i in range(len(arr))
   依次遍历数组的每一个位置，将未排序部分的最小值放到当前位置。
   
2. 内层循环：for j in range(i + 1, len(arr))
   从当前位置后面开始找比当前元素更小的值。
   
3. 最小值更新：if arr[j] < arr[min_idx]
   如果找到了一个更小的元素，就记录它的位置。
   
4. 交换：arr[i], arr[min_idx] = arr[min_idx], arr[i]
   将最小值和当前元素交换。

复杂度分析：
- 时间复杂度：
  - 最坏情况：O(n²)
  - 最好情况：O(n²)
  - 平均情况：O(n²)
- 空间复杂度：O(1) - 只使用了常数级别的额外空间

适用场景：
- 数据量较小的情况
- 对内存使用要求严格的场景（原地排序）
- 不适合对稳定性有要求的场景（选择排序是不稳定的）
- 交换次数少，适用于写操作成本高的场景

案例演示：
假设我们要对数组 [64, 34, 25, 12, 22, 11, 90] 进行排序：

第1轮选择：
- 在整个数组中找最小值，找到11，与位置0的64交换
- 数组变为 [11, 34, 25, 12, 22, 64, 90]

第2轮选择：
- 在[34, 25, 12, 22, 64, 90]中找最小值，找到12，与位置1的34交换
- 数组变为 [11, 12, 25, 34, 22, 64, 90]

思路解析：
选择排序是一种直观的排序方法，每一轮都从未排序部分选出最小元素放到已排序部分的末尾。
无论输入数据如何，都需要进行n-1轮选择，所以时间复杂度始终是O(n²)。
与冒泡排序相比，选择排序的交换次数更少，最多进行n-1次交换。
"""


### 3. 插入排序 (Insertion Sort)
### ------------------------------------------------------------------------

def insertion_sort(arr):
    """
    插入排序
    
    原理：将未排序的元素逐个插入到已排序部分，
    保证已排序部分始终是有序的。
    
    Args:
        arr: 待排序的列表
        
    Returns:
        排序后的列表
    """
    print(f"开始插入排序，初始数组: {arr}")
    # 从第二个元素开始，因为第一个元素默认是已经排序的
    for i in range(1, len(arr)):
        # 当前要插入的元素
        key = arr[i]
        # j是用来遍历已排序部分的指针
        j = i - 1
        print(f"\\n--- 第 {i} 轮插入 ---")
        print(f"  要插入的元素: {key} (位置 {i})")
        print(f"  已排序部分: {arr[:i]}")

        # 将已排序部分大于key的元素都向后移动一位
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]  # 将元素移到后面
            print(f"    将 arr[{j}]={arr[j+1]} 向后移动到 arr[{j+1}]")
            j -= 1  # 向前查找

        # 找到合适的位置，把key插入进去
        arr[j + 1] = key
        print(f"  将 {key} 插入到位置 {j+1}，数组变为: {arr}")

    print(f"插入排序完成，最终数组: {arr}")
    return arr

"""
解释：

1. 外层循环：for i in range(1, len(arr))
   从第二个元素开始，假设第一个元素已经排序好。
   
2. 插入过程：key = arr[i]
   当前要插入的元素。然后通过内层 while 循环，
   将已排序部分大于 key 的元素向右移动一位。
   
3. 插入位置：arr[j + 1] = key
   在合适的位置插入 key。

复杂度分析：
- 时间复杂度：
  - 最坏情况：O(n²) - 数组完全逆序
  - 最好情况：O(n) - 数组已经有序
  - 平均情况：O(n²)
- 空间复杂度：O(1) - 只使用了常数级别的额外空间

适用场景：
- 数据量较小的情况
- 数据基本有序的情况下效率很高
- 稳定排序算法，适用于需要保持相等元素相对位置的场景
- 在线排序（数据逐个到来）的理想选择
- 作为其他高级排序算法的子过程（如快速排序、归并排序的小数组优化）

案例演示：
假设我们要对数组 [64, 34, 25, 12, 22, 11, 90] 进行排序：

第1轮插入：
- 要插入34到已排序部分[64]中
- 34<64，将64后移，34插入位置0
- 数组变为 [34, 64, 25, 12, 22, 11, 90]

第2轮插入：
- 要插入25到已排序部分[34, 64]中
- 25<64，64后移；25<34，34后移；25插入位置0
- 数组变为 [25, 34, 64, 12, 22, 11, 90]

思路解析：
插入排序就像整理扑克牌一样，每次拿起一张新牌，从右到左找到合适的位置插入。
对于基本有序的数组，插入排序效率很高，因为大部分元素不需要移动。
对于小规模数据，插入排序通常比其他O(n²)算法更快。
"""


### 4. 归并排序 (Merge Sort)
### ------------------------------------------------------------------------

def merge_sort(arr):
    """
    归并排序
    
    原理：一种分治法排序。首先将数组分成两半，
    然后分别递归排序，再将两部分合并成一个有序的数组。
    
    Args:
        arr: 待排序的列表
        
    Returns:
        排序后的列表
    """
    print(f"分解数组: {arr}")
    # 如果数组长度大于1，则进行分割和排序
    if len(arr) > 1:
        # 找到中间点，分割数组
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]
        print(f"  分割为: 左半部分 {left_half}, 右半部分 {right_half}")

        # 递归排序左右两部分
        print(f"  递归排序左半部分:")
        left_half = merge_sort(left_half)
        print(f"  递归排序右半部分:")
        right_half = merge_sort(right_half)

        # 合并两个已经排序的部分
        i = j = k = 0
        print(f"  合并 {left_half} 和 {right_half}")
        
        # 比较两个已排序部分的元素，将较小的元素放入原数组
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                print(f"    选择左半部分元素 {left_half[i]}")
                i += 1
            else:
                arr[k] = right_half[j]
                print(f"    选择右半部分元素 {right_half[j]}")
                j += 1
            k += 1

        # 如果左边部分还有剩余，继续填充
        while i < len(left_half):
            arr[k] = left_half[i]
            print(f"    填充左半部分剩余元素 {left_half[i]}")
            i += 1
            k += 1

        # 如果右边部分还有剩余，继续填充
        while j < len(right_half):
            arr[k] = right_half[j]
            print(f"    填充右半部分剩余元素 {right_half[j]}")
            j += 1
            k += 1
            
        print(f"  合并结果: {arr}")

    return arr

"""
解释：

1. 递归分割：merge_sort(left_half) 和 merge_sort(right_half)
   递归地将数组分成两部分，直到每部分只有一个元素。
   
2. 合并操作：
   通过比较两个已排序部分的元素，将它们合并成一个更大的已排序部分。

复杂度分析：
- 时间复杂度：
  - 最坏情况：O(n log n)
  - 最好情况：O(n log n)
  - 平均情况：O(n log n)
- 空间复杂度：O(n) - 需要额外的数组来存储临时数据

适用场景：
- 数据量较大的情况
- 对稳定性有要求的场景（归并排序是稳定的）
- 对时间复杂度有稳定要求的场景（任何情况下都是O(n log n)）
- 外部排序（如处理大文件）
- 链表排序的理想选择

案例演示：
假设我们要对数组 [64, 34, 25, 12, 22, 11, 90] 进行排序：

分解过程：
[64, 34, 25, 12, 22, 11, 90]
├── [64, 34, 25, 12]
│   ├── [64, 34]
│   │   ├── [64]
│   │   └── [34]
│   │   └── 合并为 [34, 64]
│   └── [25, 12]
│       ├── [25]
│       └── [12]
│       └── 合并为 [12, 25]
│   └── 合并为 [12, 25, 34, 64]
└── [22, 11, 90]
    ├── [22, 11]
    │   ├── [22]
    │   └── [11]
    │   └── 合并为 [11, 22]
    └── [90]
    └── 合并为 [11, 22, 90]
└── 最终合并为 [11, 12, 22, 25, 34, 64, 90]

思路解析：
归并排序采用分治思想，将问题分解为更小的子问题，然后合并子问题的解得到原问题的解。
分解过程递归进行，直到每个子数组只有一个元素（自然有序）。
合并过程中通过比较两个已排序数组的元素，依次选择较小的元素放入结果数组。
由于总是选择较小元素，归并排序是稳定的排序算法。
"""


### 5. 快速排序 (Quick Sort)
### ------------------------------------------------------------------------

def quick_sort(arr):
    """
    快速排序
    
    原理：一种分治法排序，通过选择一个基准元素，
    将数组分成两部分，递归排序后合并。
    
    Args:
        arr: 待排序的列表
        
    Returns:
        排序后的列表
    """
    print(f"快速排序数组: {arr}")
    # 递归出口：如果数组为空或只有一个元素，则直接返回
    if len(arr) <= 1:
        print(f"  数组长度 <= 1，直接返回: {arr}")
        return arr

    # 选择基准元素，这里选择中间的元素
    pivot = arr[len(arr) // 2]
    print(f"  选择基准元素: {pivot}")
    
    # 将数组分成三部分：小于基准、等于基准、大于基准
    left = [x for x in arr if x < pivot]    # 小于基准
    middle = [x for x in arr if x == pivot] # 等于基准
    right = [x for x in arr if x > pivot]   # 大于基准
    print(f"  分割为: 小于基准 {left}, 等于基准 {middle}, 大于基准 {right}")

    # 递归对左边和右边部分进行排序
    print(f"  递归排序左半部分 {left}:")
    sorted_left = quick_sort(left)
    print(f"  递归排序右半部分 {right}:")
    sorted_right = quick_sort(right)
    
    result = sorted_left + middle + sorted_right
    print(f"  合并结果: {result}")
    return result

"""
解释：

1. 基准元素选择：pivot = arr[len(arr) // 2]
   选择数组的中间元素作为基准。
   
2. 三部分划分：
   通过列表推导式，将数组分成小于基准、等于基准和大于基准的三部分。
   
3. 递归排序：
   对左右部分分别进行递归排序，再将三部分合并。

复杂度分析：
- 时间复杂度：
  - 最坏情况：O(n²) - 每次选到最大或最小元素作为基准
  - 最好情况：O(n log n) - 基准总是中位数
  - 平均情况：O(n log n)
- 空间复杂度：平均 O(log n)，最坏 O(n) - 递归调用栈的深度

适用场景：
- 数据量较大的情况
- 内存使用要求不严格的情况
- 不要求稳定性的场景
- 通常是实际应用中最快的排序算法
- 适合用于大数据集的随机排序

案例演示：
假设我们要对数组 [64, 34, 25, 12, 22, 11, 90] 进行排序：

第一层递归：
- 选择基准元素 12
- 分割为: 小于基准 [], 等于基准 [12], 大于基准 [64, 34, 25, 22, 11, 90]

对右半部分 [64, 34, 25, 22, 11, 90] 继续递归：
- 选择基准元素 25
- 分割为: 小于基准 [11, 22], 等于基准 [25], 大于基准 [64, 34, 90]

继续递归直到所有子数组有序，然后合并。

思路解析：
快速排序也是一种分治算法，通过基准元素将数组分为三部分。
与归并排序不同，快速排序在分解阶段进行实际工作（分割数组），而在合并阶段不做工作。
基准元素的选择对性能影响很大，理想情况下应该选择中位数。
快速排序是不稳定的排序算法，因为相等元素可能在分割过程中改变相对位置。
"""


### 总结
### ------------------------------------------------------------------------

"""
每种排序算法的核心思想和步骤都不同，但本质上都是通过不断比较和交换或分割来将数组排序。
你可以根据数据的大小、排列顺序和内存限制来选择合适的排序算法。

时间复杂度比较：
- 冒泡排序：O(n²)
- 选择排序：O(n²)
- 插入排序：O(n²)
- 归并排序：O(n log n)
- 快速排序：平均 O(n log n)，最坏 O(n²)

空间复杂度比较：
- 冒泡排序：O(1)
- 选择排序：O(1)
- 插入排序：O(1)
- 归并排序：O(n)
- 快速排序：平均 O(log n)，最坏 O(n)

小练习：
1. 对于数组 [5, 2, 8, 1, 9, 3]，手动执行冒泡排序过程
2. 对于数组 [7, 4, 6, 2, 1, 8]，手动执行选择排序过程
3. 对于数组 [3, 1, 4, 2, 6, 5]，手动执行插入排序过程
4. 分析在什么情况下快速排序的时间复杂度会退化到O(n²)
5. 比较归并排序和快速排序在稳定性方面的差异

思路解析：
- 对于小规模数据（n<50），插入排序通常是最好的选择
- 对于大规模数据且要求稳定性，归并排序是首选
- 对于大规模数据且不要求稳定性，快速排序通常最快
- 冒泡排序虽然效率低，但概念简单，适合教学演示
- 选择排序交换次数少，适合写操作代价高的场景
"""