# -*- coding: utf-8 -*-
"""
插入排序 (Insertion Sort)
"""

def insertion_sort(arr):
    """
    插入排序
    
    原理：将未排序的元素逐个插入到已排序部分，
    保证已排序部分始终是有序的。
    
    Args:
        arr: 待排序的列表
        
    Returns:
        排序后的列表
    """
    print(f"开始插入排序，初始数组: {arr}")
    # 从第二个元素开始，因为第一个元素默认是已经排序的
    for i in range(1, len(arr)):
        # 当前要插入的元素
        key = arr[i]
        # j是用来遍历已排序部分的指针
        j = i - 1
        print(f"\n--- 第 {i} 轮插入 ---")
        print(f"  要插入的元素: {key} (位置 {i})")
        print(f"  已排序部分: {arr[:i]}")

        # 将已排序部分大于key的元素都向后移动一位
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]  # 将元素移到后面
            print(f"    将 arr[{j}]={arr[j+1]} 向后移动到 arr[{j+1}]")
            j -= 1  # 向前查找

        # 找到合适的位置，把key插入进去
        arr[j + 1] = key
        print(f"  将 {key} 插入到位置 {j+1}，数组变为: {arr}")

    print(f"插入排序完成，最终数组: {arr}")
    return arr

"""
解释：

1. 外层循环：for i in range(1, len(arr))
   从第二个元素开始，假设第一个元素已经排序好。
   
2. 插入过程：key = arr[i]
   当前要插入的元素。然后通过内层 while 循环，
   将已排序部分大于 key 的元素向右移动一位。
   
3. 插入位置：arr[j + 1] = key
   在合适的位置插入 key。

复杂度分析：
- 时间复杂度：
  - 最坏情况：O(n²) - 数组完全逆序
  - 最好情况：O(n) - 数组已经有序
  - 平均情况：O(n²)
- 空间复杂度：O(1) - 只使用了常数级别的额外空间

适用场景：
- 数据量较小的情况
- 数据基本有序的情况下效率很高
- 稳定排序算法，适用于需要保持相等元素相对位置的场景
- 在线排序（数据逐个到来）的理想选择
- 作为其他高级排序算法的子过程（如快速排序、归并排序的小数组优化）

案例演示：
假设我们要对数组 [64, 34, 25, 12, 22, 11, 90] 进行排序：

第1轮插入：
- 要插入34到已排序部分[64]中
- 34<64，将64后移，34插入位置0
- 数组变为 [34, 64, 25, 12, 22, 11, 90]

第2轮插入：
- 要插入25到已排序部分[34, 64]中
- 25<64，64后移；25<34，34后移；25插入位置0
- 数组变为 [25, 34, 64, 12, 22, 11, 90]

思路解析：
插入排序就像整理扑克牌一样，每次拿起一张新牌，从右到左找到合适的位置插入。
对于基本有序的数组，插入排序效率很高，因为大部分元素不需要移动。
对于小规模数据，插入排序通常比其他O(n²)算法更快。
"""