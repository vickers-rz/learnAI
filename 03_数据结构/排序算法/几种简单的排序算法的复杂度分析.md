### 1. **冒泡排序（Bubble Sort）**

**原理**：通过两两比较相邻元素，将较大的元素“冒泡”到数组末尾。

**代码详细注释：**

```python
def bubble_sort(arr):
    n = len(arr)  # 获取数组的长度
    
    # 外层循环控制进行多少轮比较，每一轮都会让一个最大元素浮动到数组的末尾
    for i in range(n):
        swapped = False  # 标记当前轮次是否有交换
        
        # 内层循环进行相邻元素的比较
        for j in range(0, n-i-1):  # 内层循环的长度逐渐缩小
            if arr[j] > arr[j+1]:  # 如果当前元素比下一个元素大，则交换
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True  # 标记发生了交换
        
        if not swapped:  # 如果没有交换，数组已经有序，提前退出循环
            break
    
    return arr
```

**适用场景**：

- 数据量小。
- 数组已经接近有序或已经排序的情况（因为如果没有发生交换，则提前结束）。

**算法复杂度分析**：

- **最好情况**：O(n)（数据已经有序，仅需要遍历一次）。
- **最坏情况**：O(n²)（数组完全逆序时，每一对元素都需要交换）。
- **平均情况**：O(n²)（在大多数情况下，每一对元素都会进行比较和交换）。

------

### 2. **选择排序（Selection Sort）**

**原理**：每次从未排序的部分选择最小（或最大）元素，放到已排序部分的末尾。

**代码详细注释：**

```python
def selection_sort(arr):
    for i in range(len(arr)):  # 外层循环遍历整个数组
        min_idx = i  # 假设当前位置的元素是最小值
        
        # 内层循环：从i后面的位置开始找最小的元素
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:  # 如果找到了更小的元素，更新min_idx
                min_idx = j
        
        # 交换当前位置元素和找到的最小元素
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr
```

**适用场景**：

- 数据量小。
- 需要选择最小（最大）元素的情况下。

**算法复杂度分析**：

- **最好情况**：O(n²)（选择排序不考虑是否有序，始终执行n-1次比较）。
- **最坏情况**：O(n²)（与最好情况相同，永远需要执行n-1次比较和交换）。
- **平均情况**：O(n²)（比较次数不受数据排序方式影响）。

------

### 3. **插入排序（Insertion Sort）**

**原理**：将未排序的元素逐个插入到已排序部分，保持已排序部分始终有序。

**代码详细注释：**

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):  # 从第二个元素开始
        key = arr[i]  # 当前要插入的元素
        j = i - 1  # 用来遍历已排序部分
        
        # 将已排序部分大于key的元素都向后移动一位
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]  # 移动元素
            j -= 1  # 向前查找
        
        arr[j + 1] = key  # 找到插入位置，将key插入进去
    
    return arr
```

**适用场景**：

- 数据量小。
- 数据已经接近有序。
- 稳定排序要求较高的场景。

**算法复杂度分析**：

- **最好情况**：O(n)（数据已经有序，只需要遍历一遍即可）。
- **最坏情况**：O(n²)（数据完全逆序时，每次都要移动n-1个元素）。
- **平均情况**：O(n²)（大部分情况下，每个元素都需要移动一定数量的已排序元素）。

------

### 4. **归并排序（Merge Sort）**

**原理**：分治法排序，将数组分成两半，递归排序后合并。

**代码详细注释：**

```python
def merge_sort(arr):
    if len(arr) > 1:  # 如果数组长度大于1，进行分割和排序
        mid = len(arr) // 2  # 找到中点
        left_half = arr[:mid]  # 分割左半部分
        right_half = arr[mid:]  # 分割右半部分
        
        # 递归排序左右两部分
        merge_sort(left_half)
        merge_sort(right_half)
        
        i = j = k = 0  # 用来遍历左半部分、右半部分和合并数组
        
        # 合并两个已经排序的部分
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:  # 如果左边元素较小，则放到合并数组
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1
        
        # 如果左半部分还有剩余，继续填充
        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1
        
        # 如果右半部分还有剩余，继续填充
        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1
    
    return arr
```

**适用场景**：

- 大规模数据排序。
- 需要稳定排序时。
- 外部排序：当数据过大无法放入内存时。

**算法复杂度分析**：

- **最好情况**：O(n log n)（归并排序的性能不会受到数据顺序的影响）。
- **最坏情况**：O(n log n)（每次都要分割和合并，时间复杂度稳定）。
- **平均情况**：O(n log n)（由于递归分割和合并，所有情况下时间复杂度都为O(n log n)）。

------

### 5. **快速排序（Quick Sort）**

**原理**：通过选择一个基准元素，将数组分成两部分，递归排序后合并。

**代码详细注释：**

```python
def quick_sort(arr):
    if len(arr) <= 1:  # 如果数组长度小于等于1，直接返回
        return arr
    
    pivot = arr[len(arr) // 2]  # 选择基准元素（这里选取中间的元素）
    
    left = [x for x in arr if x < pivot]  # 小于基准元素的部分
    middle = [x for x in arr if x == pivot]  # 等于基准元素的部分
    right = [x for x in arr if x > pivot]  # 大于基准元素的部分
    
    return quick_sort(left) + middle + quick_sort(right)  # 递归处理左右部分
```

**适用场景**：

- 数据量大时。
- 无需稳定排序时。

**算法复杂度分析**：

- **最好情况**：O(n log n)（基准元素能够均匀地分割数组）。
- **最坏情况**：O(n²)（每次选择的基准元素是最小或最大，导致最不平衡的划分）。
- **平均情况**：O(n log n)（通常情况下，基准元素能够分割出接近均匀的两部分，时间复杂度是O(n log n)）。

------

### 总结

| 排序算法     | 时间复杂度（最好/平均/最坏）     | 空间复杂度 | 稳定性 | 适用场景                       |
| ------------ | -------------------------------- | ---------- | ------ | ------------------------------ |
| **冒泡排序** | O(n)/O(n²)/O(n²)                 | O(1)       | 是     | 数据量小、数组接近有序时       |
| **选择排序** | O(n²)/O(n²)/O(n²)                | O(1)       | 否     | 数据量小，不需要稳定排序时     |
| **插入排序** | O(n)/O(n²)/O(n²)                 | O(1)       | 是     | 数据量小、接近有序或稳定排序时 |
| **归并排序** | O(n log n)/O(n log n)/O(n log n) | O(n)       | 是     | 大规模数据、需要稳定排序时     |
| **快速排序** | O(n log n)/O(n log n)/O(n²)      | O(log n)   | 否     | 大数据排序时，且不要求稳定性   |

每个排序算法的应用场景都不同，关键在于 **数据的规模** 和 **是否需要稳定排序**。对于大规模数据，归并排序和快速排序是不错的选择，而对于小数据量或接近有序的情况，插入排序和冒泡排序则更为合适。