# -*- coding: utf-8 -*-
"""
冒泡排序 (Bubble Sort)
"""

def bubble_sort(arr):
    """
    冒泡排序
    
    原理：通过两两比较相邻的元素，将较大的元素"冒泡"到数组的末尾。
    它会重复比较并交换，直到整个数组有序。
    
    Args:
        arr: 待排序的列表
        
    Returns:
        排序后的列表
    """
    # 获取数组的长度
    n = len(arr)
    print(f"开始冒泡排序，数组长度: {n}, 初始数组: {arr}")

    # 外层循环控制进行多少轮比较，每一轮都会让一个最大元素浮动到数组的末尾
    for i in range(n):
        print(f"\n--- 第 {i+1} 轮冒泡 ---")
        # 设置一个标志变量，用来检查是否有发生交换操作
        swapped = False

        # 内层循环进行相邻元素的比较
        # 内层循环长度逐渐缩小，因为每次外层循环后最大的元素已经"冒泡"到最后
        for j in range(0, n - i - 1):
            print(f"  比较 arr[{j}]={arr[j]} 和 arr[{j+1}]={arr[j+1]}")
            # 如果当前元素大于下一个元素，则交换它们
            if arr[j] > arr[j + 1]:
                # 交换操作，Python中的交换方式
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True  # 如果发生了交换，标记为True
                print(f"    交换后数组: {arr}")
            else:
                print(f"    无需交换")

        print(f"  第 {i+1} 轮结束，数组状态: {arr}")
        # 如果没有发生交换，说明数组已经是有序的，提前退出循环
        if not swapped:
            print("  本轮无交换，数组已有序，提前结束")
            break

    # 返回排序后的数组
    print(f"冒泡排序完成，最终数组: {arr}")
    return arr

"""
解释：

1. 外层循环：for i in range(n)
   控制排序的轮数。每完成一轮，最值会被放到末尾，
   下一轮只需要对前面未排序的部分进行排序。
   
2. 内层循环：for j in range(0, n - i - 1)
   比较相邻的元素。随着每轮外层循环的结束，i的增大，
   内层循环的范围逐渐减小。
   
3. 交换：
   如果发现相邻元素不符合顺序（例如 arr[j] > arr[j + 1]），
   则交换它们的位置。
   
4. 提前退出：
   如果某一轮没有发生任何交换，说明数组已经排好序，
   可以提前退出循环。

复杂度分析：
- 时间复杂度：
  - 最坏情况：O(n²) - 数组完全逆序
  - 最好情况：O(n) - 数组已经有序
  - 平均情况：O(n²)
- 空间复杂度：O(1) - 只使用了常数级别的额外空间

适用场景：
- 数据量较小（通常n<50）
- 数据基本有序的情况下效率较高
- 稳定排序算法，适用于需要保持相等元素相对位置的场景
- 教学演示排序算法原理的经典例子

案例演示：
假设我们要对数组 [64, 34, 25, 12, 22, 11, 90] 进行排序：

第1轮冒泡：
- 比较 64 和 34，64>34，交换 → [34, 64, 25, 12, 22, 11, 90]
- 比较 64 和 25，64>25，交换 → [34, 25, 64, 12, 22, 11, 90]
- 比较 64 和 12，64>12，交换 → [34, 25, 12, 64, 22, 11, 90]
- 比较 64 和 22，64>22，交换 → [34, 25, 12, 22, 64, 11, 90]
- 比较 64 和 11，64>11，交换 → [34, 25, 12, 22, 11, 64, 90]
- 比较 64 和 90，64<90，不交换 → [34, 25, 12, 22, 11, 64, 90]
第1轮结束，最大值90已经"冒泡"到末尾

思路解析：
冒泡排序就像水中气泡上浮一样，较大的元素会逐步"浮"到数组末尾。
每一轮都会确定一个最大元素的最终位置，所以外层循环最多需要n-1轮。
通过swapped标志可以优化最好情况下的性能。
"""